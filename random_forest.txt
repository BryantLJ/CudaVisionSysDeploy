// Tree

void ApplyFast(const IDataPointCollection& data, int& leafNodeIndex)
{
	ApplyNodeFast(0, data, leafNodeIndex);
}

// Tree

void ApplyNodeFast(int nodeIndex, const IDataPointCollection& data, int& leafNodeIndex)
{
	//assert(nodes_[nodeIndex].IsNull()==false);

	Node<F,S>& node = nodes_[nodeIndex];

	if (node.IsLeaf())
	{
		leafNodeIndex = nodeIndex;
		return;
	}

	float response = node.Feature.GetResponse(data, 0);
	if (response<node.Threshold)
		ApplyNodeFast(nodeIndex * 2 + 1, data, leafNodeIndex);
	else
		ApplyNodeFast(nodeIndex * 2 + 2, data, leafNodeIndex);
}

 
// Forest

void Apply(const IDataPointCollection& data, const unsigned int treeIndex, int& leafNodeIndex) const
{
	trees_[treeIndex]->ApplyFast(data, leafNodeIndex);
}

 

float LinearFeatureResponseBloksHOGLBP::GetResponse(const IDataPointCollection& data, unsigned int index) const
{
	// Multiply the weights by the vector to classify and sum
	const float* vFeatures = ((const DataPointCollection&)(data)).GetDataPoint((int)index);
	float output = bias_;
	for (int i=0; i<nIndex_; i=i+2) {
		output += vec4::Dot(&vFeatures[vIndex_[i]], &vWeights_[(i/2)*BLOK_SIZE_HOGLBP], BLOK_SIZE_HOG);
		output += vec4::Dot(&vFeatures[vIndex_[i+1]], &vWeights_[(i/2)*BLOK_SIZE_HOGLBP+BLOK_SIZE_HOG], BLOK_SIZE_LBP);
	}

	return output;
}

 

template<class F, class S>
inline float CSherwoodRF::ClassifySample(const IDataPointCollection& testData, const Forest<F, S>& forest) const
{
	// Classify the sample
	std::vector<int> leafNodeIndices;
	forest.ApplyParallel(testData, leafNodeIndices);

	// Aggregate statistics for this sample over all leaf nodes reached
	float prob = 0.0f;
	for (int t=0; t<forest.TreeCount(); t++) {
		prob += forest.GetTree((t)).GetNode(leafNodeIndices[t]).TrainingDataStatistics.GetProbability(1);
	}

	// Divide by the number of trees
	prob /= forest.TreeCount();

	// Return the output
	return prob;
}

 

inline float CSherwoodRF::ClassifyNoSoftCascade(const vector<float>& vFeatures) const
{
	// Convert data to Sherwood format
	std::auto_ptr<DataPointCollectionConst> testData = std::auto_ptr<DataPointCollectionConst>(new DataPointCollectionConst(&vFeatures));
	testData->SetDimension((int)vFeatures.size());
	//std::auto_ptr<DataPointCollection> testData = std::auto_ptr<DataPointCollection>(new DataPointCollection());
	//testData->SetDimension((int)vFeatures.size());
	//vector<float>& data = testData->GetData();
	//data = vFeatures;

	// Classify sample
	switch (m_featureResponseType)
	{
	case efr_linear:
		return ClassifySample(*testData, *m_pLinearForest);

	case efr_linearSVM:
		return ClassifySample(*testData, *m_pLinearForestSVM);

	case efr_linearBloksHOG:
		return ClassifySample(*testData, *m_pLinearForestBloksHOG);

	case efr_linearBloksHOGSVM:
		if (m_numForestsToCombine>1)
			return ClassifyComb(*testData, m_vLinearForestBloksHOGSVM);
		else
			return ClassifySample(*testData, *m_pLinearForestBloksHOGSVM);

	case efr_linearBloksHOGLBP:
		return ClassifySample(*testData, *m_pLinearForestBloksHOGLBP);

	case efr_linearBloksHOGLBPSVM:
		if (m_numForestsToCombine>1)
			return ClassifyComb(*testData, m_vLinearForestBloksHOGLBPSVM);
		else
			return ClassifySample(*testData, *m_pLinearForestBloksHOGLBPSVM);

	case efr_axisAligned:
		return ClassifySample(*testData, *m_pAxisForest);

	default:
		ErrorQuit(VSys_IncINIParam, "");
	return 0.0f;
	};
}
